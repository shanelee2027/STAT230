library(sos)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals,", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "Log Gun Death Rate")
library(PerformanceAnalytics)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals,", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "Log Gun Death Rate")
install.packages("PerformanceAnalytics")
knitr::opts_chunk$set(echo = TRUE)
library(PerformanceAnalytics)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals,", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "Log Gun Death Rate")
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals,", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "Log Gun Death Rate")
?rstudent
modnum <- which.max(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
modfin
modnum <- which.max(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
summary(modfin)
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals,", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "Log Gun Death Rate")
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals,", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "")
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals,", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "")
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "")
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- min(c(1:length(mod2sum$cp))[mod2sum$cp <= c(1:length(mod2sum$cp)) + 1])
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
summary(modfin)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
simdata <- rnorm(10 * 15) # need 10 * 15 values simulated
simdata <- matrix(simdata, nrow = 10, ncol = 15) # now convert this vector into a matrix
colnames(simdata) <- c("y", paste0("x", 1:14)) # add column names
simdata <- as.data.frame(simdata) # convert the matrix into a data frame
colnames(simdata)
mod1 <- lm(y ~ x1, data = simdata)
mod1
summary(mod1)$r.squared
simtemp <- simdata[,1:8]
m7 <- lm(y ~ ., data = simtemp)
rsqvals <- c()
for (x in 1:14) {
simtemp <- simdata[,1:(x+1)]
# print(simtemp)
tempmodel <- lm(y ~ ., simtemp)
rsqvals[x] = summary(tempmodel)$r.squared
}
rsqvals
match(1, rsqvals)
plot(rsqvals,
main="R-squared Values with Varying Predictors",
xlab="Number of Predictors",
ylab="R-squared Value",
col='red')
crime <- read.csv('https://raw.githubusercontent.com/jreuning/sds230_data/refs/heads/main/ohiocrime.csv')
dim(crime)
names(crime)
head(crime)
#note the options above are to make plots work properly in the corrplot package.
#Load the corrplot package
library(corrplot)
#calculate pairwise correlations for columns 10-23 of crime.  You'll need the   use = "pairwise.complete.obs" option.
cor1 <- cor(crime[10:23], use="pairwise.complete.obs", method="pearson")
#round cor1 to 2 decimal places and display the result.
cor1 <- round(cor1, digits=2)
cor1
#finds the exact cell of cor1 which contains the maximum positive pairwise
# correlation (other than 1), and stores that cell in maxloc
maxloc <- which(cor1 == max(cor1[cor1<1]), arr.ind = TRUE)
#prints the names of the columns of maxloc, which would be the two columns
# with the maximum positive pairwise correlation
names(crime[10:23])[maxloc[1,]]
#Create an object called sigcorr that has the results of cor.mtest for columns 10-23 of the crime data.  Use 95% CI.
sigcorr <- cor.mtest(crime[10:23], conf.level = 0.95)
#Use corrplot.mixed to display confidence ellipses, pairwise correlation values, and put on 'X' over non-significant values.
corrplot.mixed(cor1, lower.col="black", upper = "ellipse", tl.col = "black", number.cex=.7,
tl.pos = "lt", tl.cex=.7, p.mat = sigcorr$p, sig.level = .05)
plot(x=crime$V10,
y=crime$V19,
col="red",
main="Comparison Between Support for Two Prompts",
xlab="Support for State-Provided Jobs to Low-Income Inner-City Youths",
ylab="Support for State-run Youth Apprenticeship Programs",
pch=19)
plot(x=jitter(crime$V10, factor=1),
y=jitter(crime$V19, factor=1),
col="red",
main="Comparison Between Support for Two Prompts",
xlab="Support for State-Provided Jobs to Low-Income Inner-City Youths",
ylab="Support for State-run Youth Apprenticeship Programs",
pch=19)
crime2 <- crime[, c(45, 10:23, 65, 70, 72, 87, 86)]
names(crime2)
dim(crime2)
library(leaps)
mod2 <- regsubsets(V45 ~ ., data = crime2, nvmax = 19)
mod2sum <- summary(mod2)
mod2sum$which
modnum <- which.max(mod2sum$rsq)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.max(mod2sum$adjr2)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- min(c(1:length(mod2sum$cp))[mod2sum$cp <= c(1:length(mod2sum$cp)) + 1])
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
summary(modfin)
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "")
CIs <- confint(modfin)
coefs <- coef(modfin)
library(plotrix)
install.packages("plotrix")
CIs <- confint(modfin)
coefs <- coef(modfin)
library(plotrix)
plotCI(1:(length(coefs)-1), coefs[-1],
ui = CIs[-1,2], li = CIs[-1,1],
xlab = "",
ylab = "Coefficient (and 95% CI)",
main = "Final Crime Model Coefficients and CI's",
axes = FALSE, lwd = 2, col = "blue")
abline(h = 0, lty = 2, lwd = 3, col = "red")
axis(side = 2)
axis(side = 1, at = 1:(length(coefs)-1), label = names(coefs)[-1], las = 2)
CIs <- confint(modfin)
coefs <- coef(modfin)
library(plotrix)
plotCI(1:(length(coefs)-1), coefs[-1],
ui = CIs[-1,2], li = CIs[-1,1],
xlab = "",
ylab = "Coefficient (and 95% CI)",
main = "Final Crime Model Coefficients and CI's",
axes = FALSE, lwd = 2, col = "blue")
abline(h = 0, lty = 2, lwd = 3, col = "red")
axis(side = 2)
axis(side = 1, at = 1:(length(coefs)-1), label = names(coefs)[-1], las = 2)
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
summary(modfin)
summary(modfin)$r.squared
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
simdata <- rnorm(10 * 15) # need 10 * 15 values simulated
simdata <- matrix(simdata, nrow = 10, ncol = 15) # now convert this vector into a matrix
colnames(simdata) <- c("y", paste0("x", 1:14)) # add column names
simdata <- as.data.frame(simdata) # convert the matrix into a data frame
colnames(simdata)
mod1 <- lm(y ~ x1, data = simdata)
mod1
summary(mod1)$r.squared
simtemp <- simdata[,1:8]
m7 <- lm(y ~ ., data = simtemp)
rsqvals <- c()
for (x in 1:14) {
simtemp <- simdata[,1:(x+1)]
# print(simtemp)
tempmodel <- lm(y ~ ., simtemp)
rsqvals[x] = summary(tempmodel)$r.squared
}
rsqvals
match(1, rsqvals)
plot(rsqvals,
main="R-squared Values with Varying Predictors",
xlab="Number of Predictors",
ylab="R-squared Value",
col='red')
crime <- read.csv('https://raw.githubusercontent.com/jreuning/sds230_data/refs/heads/main/ohiocrime.csv')
dim(crime)
names(crime)
head(crime)
#note the options above are to make plots work properly in the corrplot package.
#Load the corrplot package
library(corrplot)
#calculate pairwise correlations for columns 10-23 of crime.  You'll need the   use = "pairwise.complete.obs" option.
cor1 <- cor(crime[10:23], use="pairwise.complete.obs", method="pearson")
#round cor1 to 2 decimal places and display the result.
cor1 <- round(cor1, digits=2)
cor1
#finds the exact cell of cor1 which contains the maximum positive pairwise
# correlation (other than 1), and stores that cell in maxloc
maxloc <- which(cor1 == max(cor1[cor1<1]), arr.ind = TRUE)
#prints the names of the columns of maxloc, which would be the two columns
# with the maximum positive pairwise correlation
names(crime[10:23])[maxloc[1,]]
#Create an object called sigcorr that has the results of cor.mtest for columns 10-23 of the crime data.  Use 95% CI.
sigcorr <- cor.mtest(crime[10:23], conf.level = 0.95)
#Use corrplot.mixed to display confidence ellipses, pairwise correlation values, and put on 'X' over non-significant values.
corrplot.mixed(cor1, lower.col="black", upper = "ellipse", tl.col = "black", number.cex=.7,
tl.pos = "lt", tl.cex=.7, p.mat = sigcorr$p, sig.level = .05)
plot(x=crime$V10,
y=crime$V19,
col="red",
main="Comparison Between Support for Two Prompts",
xlab="Support for State-Provided Jobs to Low-Income Inner-City Youths",
ylab="Support for State-run Youth Apprenticeship Programs",
pch=19)
plot(x=jitter(crime$V10, factor=1),
y=jitter(crime$V19, factor=1),
col="red",
main="Comparison Between Support for Two Prompts",
xlab="Support for State-Provided Jobs to Low-Income Inner-City Youths",
ylab="Support for State-run Youth Apprenticeship Programs",
pch=19)
crime2 <- crime[, c(45, 10:23, 65, 70, 72, 87, 86)]
names(crime2)
dim(crime2)
library(leaps)
mod2 <- regsubsets(V45 ~ ., data = crime2, nvmax = 19)
mod2sum <- summary(mod2)
mod2sum$which
modnum <- which.max(mod2sum$rsq)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.max(mod2sum$adjr2)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- min(c(1:length(mod2sum$cp))[mod2sum$cp <= c(1:length(mod2sum$cp)) + 1])
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
summary(modfin)
summary(modfin)$r.squared
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "")
CIs <- confint(modfin)
coefs <- coef(modfin)
library(plotrix)
plotCI(1:(length(coefs)-1), coefs[-1],
ui = CIs[-1,2], li = CIs[-1,1],
xlab = "",
ylab = "Coefficient (and 95% CI)",
main = "Final Crime Model Coefficients and CI's",
axes = FALSE, lwd = 2, col = "blue")
abline(h = 0, lty = 2, lwd = 3, col = "red")
axis(side = 2)
axis(side = 1, at = 1:(length(coefs)-1), label = names(coefs)[-1], las = 2)
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
simdata <- rnorm(10 * 15) # need 10 * 15 values simulated
simdata <- matrix(simdata, nrow = 10, ncol = 15) # now convert this vector into a matrix
colnames(simdata) <- c("y", paste0("x", 1:14)) # add column names
simdata <- as.data.frame(simdata) # convert the matrix into a data frame
colnames(simdata)
mod1 <- lm(y ~ x1, data = simdata)
mod1
summary(mod1)$r.squared
simtemp <- simdata[,1:8]
m7 <- lm(y ~ ., data = simtemp)
rsqvals <- c()
for (x in 1:14) {
simtemp <- simdata[,1:(x+1)]
# print(simtemp)
tempmodel <- lm(y ~ ., simtemp)
rsqvals[x] = summary(tempmodel)$r.squared
}
rsqvals
match(1, rsqvals)
plot(rsqvals,
main="R-squared Values with Varying Predictors",
xlab="Number of Predictors",
ylab="R-squared Value",
col='red')
crime <- read.csv('https://raw.githubusercontent.com/jreuning/sds230_data/refs/heads/main/ohiocrime.csv')
dim(crime)
names(crime)
head(crime)
#note the options above are to make plots work properly in the corrplot package.
#Load the corrplot package
library(corrplot)
#calculate pairwise correlations for columns 10-23 of crime.  You'll need the   use = "pairwise.complete.obs" option.
cor1 <- cor(crime[10:23], use="pairwise.complete.obs", method="pearson")
#round cor1 to 2 decimal places and display the result.
cor1 <- round(cor1, digits=2)
cor1
#finds the exact cell of cor1 which contains the maximum positive pairwise
# correlation (other than 1), and stores that cell in maxloc
maxloc <- which(cor1 == max(cor1[cor1<1]), arr.ind = TRUE)
#prints the names of the columns of maxloc, which would be the two columns
# with the maximum positive pairwise correlation
names(crime[10:23])[maxloc[1,]]
#Create an object called sigcorr that has the results of cor.mtest for columns 10-23 of the crime data.  Use 95% CI.
sigcorr <- cor.mtest(crime[10:23], conf.level = 0.95)
#Use corrplot.mixed to display confidence ellipses, pairwise correlation values, and put on 'X' over non-significant values.
corrplot.mixed(cor1, lower.col="black", upper = "ellipse", tl.col = "black", number.cex=.7,
tl.pos = "lt", tl.cex=.7, p.mat = sigcorr$p, sig.level = .05)
plot(x=crime$V10,
y=crime$V19,
col="red",
main="Comparison Between Support for Two Prompts",
xlab="Support for State-Provided Jobs to Low-Income Inner-City Youths",
ylab="Support for State-run Youth Apprenticeship Programs",
pch=19)
plot(x=jitter(crime$V10, factor=1),
y=jitter(crime$V19, factor=1),
col="red",
main="Comparison Between Support for Two Prompts",
xlab="Support for State-Provided Jobs to Low-Income Inner-City Youths",
ylab="Support for State-run Youth Apprenticeship Programs",
pch=19)
crime2 <- crime[, c(45, 10:23, 65, 70, 72, 87, 86)]
names(crime2)
dim(crime2)
library(leaps)
mod2 <- regsubsets(V45 ~ ., data = crime2, nvmax = 19)
mod2sum <- summary(mod2)
mod2sum$which
modnum <- which.max(mod2sum$rsq)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.max(mod2sum$adjr2)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- min(c(1:length(mod2sum$cp))[mod2sum$cp <= c(1:length(mod2sum$cp)) + 1])
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
summary(lm(V45 ~ ., data = crimetemp))
modnum <- which.min(mod2sum$bic)
modnum
names(crime2)[mod2sum$which[modnum, ]][-1]
crimetemp <- crime2[ ,mod2sum$which[modnum, ]]
modfin <- lm(V45 ~ ., data = crimetemp)
summary(modfin)
summary(modfin)$r.squared
library(car)
myResPlots <- function(model, label){
#Normal quantile plot of studentized residuals
qqPlot(rstudent(model), pch = 19, main = paste("NQ Plot of Studentized Residuals", label))
#plot of fitted vs. studentized residuals
plot(rstudent(model) ~ model$fitted.values, pch = 19, col = 'red', xlab = "Fitted Values", ylab = "Studentized Residuals",
main = paste("Fits vs. Studentized Residuals", label))
abline(h = 0, lwd = 3)
abline(h = c(2,-2), lty = 2, lwd = 2, col="blue")
abline(h = c(3,-3), lty = 2, lwd = 2, col="green")
}
myResPlots(modfin, label = "")
CIs <- confint(modfin)
coefs <- coef(modfin)
library(plotrix)
plotCI(1:(length(coefs)-1), coefs[-1],
ui = CIs[-1,2], li = CIs[-1,1],
xlab = "",
ylab = "Coefficient (and 95% CI)",
main = "Final Crime Model Coefficients and CI's",
axes = FALSE, lwd = 2, col = "blue")
abline(h = 0, lty = 2, lwd = 3, col = "red")
axis(side = 2)
axis(side = 1, at = 1:(length(coefs)-1), label = names(coefs)[-1], las = 2)
